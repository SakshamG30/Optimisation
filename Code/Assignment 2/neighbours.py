# Copyright subsists in all the material on this repository and vests in the ANU
# (or other parties). Any copying of the material from this site other than for
# the purpose of working on this assignment is a breach of copyright.
#
# In practice, this means that you are not allowed to make any of the existing
# material in this repository nor your assignment available to others (except to
# the course lecturers and tutors) at any time before, during, or after the
# course. In particular, you must keep any clone of this repository and any
# extension of it private at all times.
import random

from nurse import DAYS_PER_WEEK, SHIFTS
from nurse import RosteringProblem, load_last_roster


class Neighbourhood:
    '''
    A neighbourhood is a class that computes explicitly neighbours of a roster.
    '''

    def neighbours(self, roster):
        '''
          Returns a list of feasible rosters that are neighbours of this roster.
        '''
        pass


# Neighbourhood 0
class SwapNeighbourhood(Neighbourhood):
    '''
      Example of a neighbourhood.
      A roster r' is a neighbour of a roster r
      if it can be obtained by swapping the schedule of exactly two nurses.
    '''

    def __init__(self, prob) -> None:
        self._prob = prob

    def neighbours(self, roster):
        result = []
        for i in range(self._prob._nb_nurses):
            for j in range(i + 1, self._prob._nb_nurses):
                # Swaps the schedules of nurses i and j.
                new_roster = [line for line in
                              roster]  # notice that we can do that because strings are immutable (no risk of side effects)
                new_roster[i] = roster[j]
                new_roster[j] = roster[i]
                #if not self._prob.is_feasible(new_roster) == None:
                #    continue
                # No need to test for feasibility: this new roster is guaranteed to be feasible (assuming the specified one was feasible).
                result.append(new_roster)
        return result


# Neighbourhood 1
"""
Alternating Shift and Reverse Block Neighbourhood

Purpose: This neighbourhood generates neighbouring rosters by applying an alternating sequence of shift and reverse operations within a selected block of consecutive workdays (A, P, N) in a nurse's schedule.
Each neighbouring roster is formed by modifying the selected block with alternating transformations, creating unique variations that introduce structural changes while maintaining the overall schedule balance.

Design Details:
- For each nurse and each block of consecutive days:
    - Shift operation: Positions of shifts within the block are altered by moving the first shift to the end on even days.
    - Reverse operation: On alternate days, shifts are reversed, adding variability.
- The new configuration is tested for feasibility to ensure it meets all scheduling constraints.

Reason for Inclusion: By combining shift and reverse operations in an alternating pattern, this neighbourhood generates larger, varied transformations that can help escape local optima and explore diverse schedules. 
This structure is particularly useful in Variable Neighborhood Search (VNS) to diversify the solution space.
"""


class AlternatingShiftAndReverseBlockNeighbourhood(Neighbourhood):
    '''
    Generates neighbouring rosters by shifting and alternately reversing individual days within a block of consecutive
    workdays in a single nurse's schedule.

    Attributes:
        _prob (RosteringProblem): The rostering problem instance containing scheduling constraints and parameters.
    '''

    def __init__(self, prob) -> None:
        self._prob = prob

    def neighbours(self, roster):
        '''
        Generates a list of neighbouring rosters by applying alternating shift and reverse transformations within blocks of
        consecutive workdays for each nurse in the roster.

        Args:
            roster (List[str]): The current feasible roster of nurse schedules.

        Returns:
            List[List[str]]: A list of neighbouring rosters generated by transforming blocks of shifts within a nurse's schedule.
        '''
        result = []

        # Iterate over all nurses
        for i in range(self._prob._nb_nurses):
            for start in range(len(roster[0])):  # Iterate over all possible start days
                for length in range(2, min(5, len(roster[0]) - start)):  # Block length between 2 to 4 days

                    # Create a copy of the roster to manipulate
                    new_roster = [list(line) for line in roster]

                    # Shift the block by moving the first shift to the end
                    block = new_roster[i][start:start + length]

                    # Apply alternating shifts and reversals
                    block_transformed = []
                    for idx, day in enumerate(block):
                        if idx % 2 == 0:
                            # Shift: Move the first day to the end (Shift every other day forward)
                            block_transformed.append(day)
                        else:
                            # Reverse: Reverse the order of every alternate day
                            block_transformed.insert(0, day)

                    # Replace the original block with the alternately transformed block
                    new_roster[i][start:start + length] = block_transformed

                    # Convert back to the string format
                    new_roster_str = [''.join(line) for line in new_roster]

                    # Check if the new roster is feasible
                    if self._prob.is_feasible(new_roster_str) is None:
                        result.append(new_roster_str)

        return result


# Neighbourhood 2
"""
Randomized Block Swap and Reverse Neighbourhood

Purpose: This neighbourhood explores neighbouring rosters by performing random operations—shifting, reversing, 
or swapping shifts within a selected block of consecutive workdays (A, P, N) within a single nurse's schedule. 
Each neighbour roster is formed by selecting a block, applying one of the transformations, and checking for feasibility.

Design Details:
- For each nurse in the roster, select a block of consecutive workdays.
- Randomly choose one of three operations to apply:
    - Shift: Rotate the block forward by one position.
    - Reverse: Flip the order of shifts in the block.
    - Swap: Swap the first and last shifts within the block.
- The function tests each modified roster for feasibility before adding it to the neighbouring rosters.

Reason for Inclusion: By allowing multiple types of transformations within a single block, this neighbourhood 
performs diverse adjustments that go beyond single shifts. This helps the algorithm break free from local optima 
by exploring significantly varied solutions while still preserving the overall structure of each nurse’s schedule.
"""


class RandomizedBlockSwapAndReverseNeighbourhood(Neighbourhood):
    '''
    Generates neighbouring rosters by randomly performing a shift, reverse, or swap operation on a block of
    consecutive workdays within a nurse's schedule.

    Attributes:
        _prob (RosteringProblem): Instance of the rostering problem containing constraints and parameters.
    '''

    def __init__(self, prob) -> None:
        self._prob = prob

    def neighbours(self, roster):
        '''
        Generates a list of neighbouring rosters by performing random block operations (shift, reverse, or swap)
        on blocks of consecutive workdays for each nurse in the roster.

        Args:
            roster (List[str]): The current feasible roster of nurse schedules.

        Returns:
            List[List[str]]: A list of neighbouring rosters generated by modifying blocks of shifts within a single nurse's schedule.
        '''
        result = []

        # Iterate over all nurses
        for i in range(self._prob._nb_nurses):
            for start in range(len(roster[0])):  # Iterate over all possible start days
                for length in range(2, min(5, len(roster[0]) - start)):  # Block length between 2 to 4 days

                    # Create a copy of the roster to manipulate
                    new_roster = [list(line) for line in roster]

                    # Extract the block of shifts
                    block = new_roster[i][start:start + length]

                    # Randomly choose an operation: shift, reverse, or swap shifts within the block
                    operation = random.choice(["shift", "reverse", "swap"])

                    if operation == "shift":
                        block = block[1:] + block[:1]  # Shift the block by 1 position
                    elif operation == "reverse":
                        block = block[::-1]  # Reverse the block
                    elif operation == "swap":
                        if len(block) > 1:
                            # Swap the first and last shift in the block
                            block[0], block[-1] = block[-1], block[0]

                    # Replace the original block with the modified block
                    new_roster[i][start:start + length] = block

                    # Convert back to the string format
                    new_roster_str = [''.join(line) for line in new_roster]

                    # Check if the new roster is feasible
                    if self._prob.is_feasible(new_roster_str) is None:
                        result.append(new_roster_str)

        return result


# Neighbourhood 3
"""
Shift Block Reverse Neighbourhood
Purpose: This neighbourhood generates neighbouring rosters by reversing blocks of consecutive workdays (A, P, N) within a 
single nurse's schedule. This means a nurse’s consecutive shifts in a selected block are reversed, creating a variation 
in shift sequence while maintaining the same workdays.

Design Details:
- For each nurse, iterate over all possible start days and block lengths of 2 to 4 days.
- Reverse the order of shifts within the selected block for each nurse, modifying the schedule's internal structure.
- After each reversal, the modified roster is checked for feasibility to ensure it adheres to all scheduling constraints.

Reason for Inclusion: By reversing shift blocks, this neighbourhood provides moderate yet meaningful modifications to explore 
local optima. Reversing consecutive days allows variations that maintain the shift sequence but alter the order, 
diversifying potential solutions in Variable Neighborhood Search (VNS).
"""


class ShiftBlockReverseNeighbourhood(Neighbourhood):
    '''
    Generates neighbouring rosters by reversing a block of consecutive workdays within a single nurse's schedule.

    Attributes:
        _prob (RosteringProblem): The rostering problem instance containing scheduling constraints and parameters.
    '''

    def __init__(self, prob) -> None:
        self._prob = prob

    def neighbours(self, roster):
        '''
        Generates neighbouring rosters by reversing blocks of consecutive days in a single nurse's schedule.

        Args:
            roster (List[str]): The current feasible roster as a list of nurse schedules.

        Returns:
            List[List[str]]: A list of neighbouring rosters created by reversing blocks within a nurse's schedule.
        '''
        result = []

        # Iterate over all nurses
        for i in range(self._prob._nb_nurses):
            for start in range(len(roster[0])):  # Iterate over all possible start days
                for length in range(2, min(5, len(roster[0]) - start)):  # Block length between 2 to 4 days

                    # Create a copy of the roster to manipulate
                    new_roster = [list(line) for line in roster]

                    # Shift the block by moving the first shift to the end
                    block = new_roster[i][start:start + length]
                    block_shifted = block[1:] + block[:1]  # Shift the block by 1 position

                    # Reverse the shifted block
                    block_reversed = block_shifted[::-1]

                    # Replace the original block with the reversed shifted block
                    new_roster[i][start:start + length] = block_reversed

                    # Convert back to the string format
                    new_roster_str = [''.join(line) for line in new_roster]

                    # Check if the new roster is feasible
                    if self._prob.is_feasible(new_roster_str) is None:
                        result.append(new_roster_str)

        return result


# Neighbourhood 4
"""
Cycle Shifts Neighbourhood

Purpose: This neighbourhood cyclically rotates the shifts of all nurses forward or backward by a specified number 
of days, shifting each nurse's schedule by 1 to 10 days, with wrap-around at the roster's end. For example, a forward 
shift moves Day 0 to Day 1, Day 1 to Day 2, and so on, with the final day cycling back to the start.

Design Details: The neighbourhood explores a range of shifts, from 1 to 10 days, applying both forward and backward 
rotations to create diverse configurations. Each shift amount generates a unique variation of the roster, preserving 
the schedule length and structural integrity.

Reason for Inclusion: By facilitating large-scale adjustments while preserving individual schedule order, the Cycle 
Shifts Neighbourhood allows exploration of broader areas within the search space. This helps the algorithm escape 
local optima, introducing variety that can guide toward more globally optimal solutions.
"""


class CycleShiftsNeighbourhood(Neighbourhood):
    '''
    A neighbourhood in which each neighbour is generated by cyclically shifting the schedules
    of all nurses either forward or backward by a set number of days (1 to 10).

    Attributes:
        _prob (RosteringProblem): An instance of the rostering problem, containing the setup and constraints.
    '''

    def __init__(self, prob) -> None:
        self._prob = prob

    def neighbours(self, current_roster):
        '''
        Generates neighbouring rosters by cyclically shifting all nurses' schedules forward or backward by 1 to 10 days.

        Args:
            current_roster (List[str]): The current feasible roster, represented as a list of nurse schedules.

        Returns:
            List[List[str]]: A list of neighbouring rosters created by cyclically shifting all schedules.
        '''
        result = []  # List to store all cyclically shifted rosters

        # Initialize shift_amount for the while loop
        shift_amount = 1

        # Generate cyclic shifts from 1 to 10 positions using a while loop
        while shift_amount <= 10:
            # Shift forward by 'shift_amount' positions for all nurses
            shifted_roster_forward = [nurse_schedule[-shift_amount:] + nurse_schedule[:-shift_amount] for nurse_schedule
                                      in current_roster]
            result.append(shifted_roster_forward)  # Add forward-shifted roster to results

            # Shift backward by 'shift_amount' positions for all nurses
            shifted_roster_backward = [nurse_schedule[shift_amount:] + nurse_schedule[:shift_amount] for nurse_schedule
                                       in current_roster]
            result.append(shifted_roster_backward)  # Add backward-shifted roster to results

            # Increment shift_amount for the next cycle
            shift_amount += 1

        return result


# Neighbourhood 5
"""
Block Shifts Swap Neighbourhood

Purpose: This neighbourhood generates neighbouring rosters by swapping blocks of consecutive 
days between two nurses, enabling a roster `r` to have a neighbour `r'` through the exchange 
of a specific block of consecutive days between any selected nurse pair.

Design Details: For each unique pair of nurses, a starting day and block length (up to 5 
consecutive days or less if nearing the roster’s end) are chosen. Swapping these blocks 
creates a new roster configuration, which is then validated against feasibility constraints.

Reason for Inclusion: By allowing for larger local changes through multiple consecutive 
shift swaps, the Block Shifts Swap Neighbourhood introduces greater diversity in the search 
space. This design helps break from local optima effectively, offering a strategic way 
to explore varied configurations while maintaining balance across shifts.
"""


class BlockShiftsSwapNeighbourhood(Neighbourhood):
    '''
    Generates a neighbouring roster by swapping a block of consecutive days between two nurses.
    A roster r' is considered a neighbour of roster r if it can be obtained by swapping a block
    of consecutive days between any two nurses.

    Attributes:
        _prob (RosteringProblem): An instance of the rostering problem, containing nurse and scheduling constraints.
    '''

    def __init__(self, prob) -> None:
        self._prob = prob

    def neighbours(self, roster):
        '''
        Generates neighbouring rosters by swapping blocks of consecutive days between pairs of nurses.

        Args:
            roster (List[str]): The current feasible roster, represented as a list of nurse schedules.

        Returns:
            List[List[str]]: A list of neighbouring rosters created by swapping blocks of consecutive days.
        '''
        result = []  # List to store all valid neighbouring rosters

        # Iterate over each unique pair of nurses
        for first_nurse in range(self._prob._nb_nurses):
            for second_nurse in range(first_nurse + 1, self._prob._nb_nurses):

                # Iterate over possible starting positions for the block
                for start_day in range(len(roster[0])):
                    # Limit block length to avoid exceeding roster length
                    for block_length in range(1, min(5, len(roster[0]) - start_day)):
                        # Create a copy of the roster to make modifications
                        new_roster = [list(schedule) for schedule in roster]

                        # Swap blocks between nurse_a and nurse_b
                        new_roster[first_nurse][start_day:start_day + block_length], \
                            new_roster[second_nurse][start_day:start_day + block_length] = \
                            new_roster[second_nurse][start_day:start_day + block_length], \
                                new_roster[first_nurse][start_day:start_day + block_length]

                        # Check feasibility of the new roster configuration
                        modified_roster = [''.join(schedule) for schedule in new_roster]
                        if self._prob.is_feasible(modified_roster) is None:
                            result.append(modified_roster)  # Add valid neighbour to results

        return result


# Neighbourhood 6
"""
One Shift Change Neighbourhood

Purpose: This neighbourhood generates neighbouring rosters by changing a single shift for a specific 
nurse on a randomly selected day, introducing small adjustments to explore variations in the roster.

Design Details:
- For each nurse, the neighbourhood changes only one shift on a specific day.
- Each neighbouring roster is created by modifying a single shift while keeping all other aspects of the schedule the same.

Reason for Inclusion: By allowing single shift changes, this neighbourhood achieves minimal adjustments that 
help to explore fine-grained variations, allowing fine-tuning around promising configurations and exploring 
slight changes to approach optimal solutions.
"""


class OneShiftChangeNeighbourhood(Neighbourhood):
    '''
    Generates neighbouring rosters by changing one or two shifts for a single nurse on specific days.

    Attributes:
        _prob (RosteringProblem): Instance of the rostering problem, containing scheduling constraints.
    '''

    def __init__(self, prob) -> None:
        self._prob = prob  # Rostering problem instance with constraints

    def neighbours(self, current_roster):
        '''
        Generates neighbouring rosters by making either a single or a double shift change for a specified nurse.

        Args:
            current_roster (List[str]): The current roster configuration, where each entry is a nurse's schedule.

        Returns:
            List[List[str]]: A list of neighbouring rosters, each created by changing one or two shifts for a single nurse.
        '''
        result = []  # List to store generated neighbouring rosters

        # Iterate over each nurse
        for nurse_index in range(self._prob._nb_nurses):
            # Iterate over each day in the nurse's schedule
            for day in range(self._prob._nb_weeks * DAYS_PER_WEEK):
                current_shift = current_roster[nurse_index][day]  # Current shift of the nurse on that day

                # Attempt each possible shift that isn't the current shift
                for new_shift in SHIFTS - {current_shift}:
                    # Create a copy of the current roster to modify
                    new_roster = [line for line in current_roster]
                    # Update the nurse's shift for the selected day
                    new_roster[nurse_index] = new_roster[nurse_index][:day] + new_shift + new_roster[nurse_index][
                                                                                          day + 1:]

                    # Append the modified roster to the result list
                    result.append(new_roster)

        return result


# Neighbourhood 7
"""
Double Swap Neighbourhood
Purpose: Generates neighbouring rosters by performing a double swap, where two distinct pairs of nurses' 
schedules are swapped within the roster. Each neighbouring roster is created through two sequential, 
independent swaps, each involving a unique pair of nurses.

Design Details: For each neighbouring roster, an initial pair of nurses is selected and swapped, 
followed by a second unique pair. This sequence of swaps results in diverse configurations, 
enabling broader exploration of potential rosters.

Reason for Inclusion: The DoubleSwapNeighbourhood approach extends the SwapNeighbourhood (which swaps a single pair of nurses) 
by allowing for two independent swaps, which effectively helps break out of local optima in the Variable Neighborhood Search (VNS) algorithm. 
This additional complexity provides a balance between diversification (exploring the search space) and 
intensification (refining promising configurations), making it highly valuable for robust solution search.
"""


class DoubleSwapNeighbourhood(Neighbourhood):
    '''
    Neighbourhood that generates neighbours of a roster by performing double swaps, where exactly two pairs of nurse schedules are swapped.

    Attributes:
        _prob (RosteringProblem): The rostering problem instance containing scheduling constraints and parameters.
    '''

    def __init__(self, prob) -> None:
        self._prob = prob

    def neighbours(self, roster):
        '''
        Generates a list of neighbouring rosters by swapping the schedules of two pairs of nurses.

        Args:
            roster (List[str]): The current feasible roster of nurse schedules.

        Returns:
            List[List[str]]: A list of neighbouring rosters created by performing double swaps, where each roster
                             is generated by swapping two pairs of nurse schedules.
        '''
        result = []
        # First loop: select the first pair of nurses to swap
        for first_nurse in range(self._prob._nb_nurses):
            for second_nurse in range(first_nurse + 1, self._prob._nb_nurses):
                # Second loop: select the second pair of nurses to swap
                for third_nurse in range(self._prob._nb_nurses):
                    # Ensure we don’t select the same nurse for both swaps
                    if third_nurse == first_nurse or third_nurse == second_nurse:
                        continue
                    for fourth_nurse in range(third_nurse + 1, self._prob._nb_nurses):
                        if fourth_nurse == first_nurse or fourth_nurse == second_nurse:
                            continue

                        # Perform the double swap
                        new_roster = roster.copy()

                        # Swap first pair (first_nurse, second_nurse)
                        new_roster[first_nurse], new_roster[second_nurse] = new_roster[second_nurse], new_roster[
                            first_nurse]

                        # Swap second pair (third_nurse, fourth_nurse)
                        new_roster[third_nurse], new_roster[fourth_nurse] = new_roster[fourth_nurse], new_roster[
                            third_nurse]

                        # Add the new roster to the result list
                        result.append(new_roster)

        return result
